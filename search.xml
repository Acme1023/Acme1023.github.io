<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「九省联考 2018」部分题解</title>
      <link href="/2019/04/02/20190402-SHOI2018-Tutorial/"/>
      <url>/2019/04/02/20190402-SHOI2018-Tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>快要省选了。这个小菜鸡准备在考前突击一下——把去年的省选题做完。</p><p>但是他太菜了，看了题解之后也只会四道题目。</p><p>今年他究竟能否进入省队呢？让我们拭目以待。</p><p>2019.4.7 upd: 最后还是苟进省队了 QAQ</p><a id="more"></a><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>好的现在我们步入正题 —— 九省联考 2018 题解。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Day \ Task</th><th style="text-align:center">Task 1</th><th style="text-align:center">Task 2</th><th style="text-align:center">Task 3</th></tr></thead><tbody><tr><td style="text-align:center">Day 1</td><td style="text-align:center">一双木棋 <a href="https://www.luogu.org/problemnew/show/P4363" target="_blank" rel="noopener">链接</a> <a href="https://acme1023.github.io/2019/04/02/20190402-SHOI2018-Tutorial/#%E3%80%8CDay-1-Task-1%E3%80%8D%E4%B8%80%E5%8F%8C%E6%9C%A8%E6%A3%8B" target="_blank" rel="noopener">题解</a></td><td style="text-align:center">IIIDX <a href="https://www.luogu.org/problemnew/show/P4364" target="_blank" rel="noopener">链接</a> <a href="https://acme1023.github.io/2019/04/02/20190402-SHOI2018-Tutorial/#%E3%80%8CDay-1-Task-2%E3%80%8DIIIDX" target="_blank" rel="noopener">题解</a></td><td style="text-align:center">秘密袭击 <a href="https://www.luogu.org/problemnew/show/P4365" target="_blank" rel="noopener">链接</a> 暂无题解</td></tr><tr><td style="text-align:center">Day 2</td><td style="text-align:center">劈配 <a href="https://www.luogu.org/problemnew/show/P4382" target="_blank" rel="noopener">链接</a> <a href="https://acme1023.github.io/2019/04/02/20190402-SHOI2018-Tutorial/#%E3%80%8CDay-2-Task-1%E3%80%8D%E5%8A%88%E9%85%8D" target="_blank" rel="noopener">题解</a></td><td style="text-align:center">林克卡特树 <a href="https://www.luogu.org/problemnew/show/P4383" target="_blank" rel="noopener">链接</a> <a href="https://acme1023.github.io/2019/04/02/20190402-SHOI2018-Tutorial/#%E3%80%8CDay-2-Task-2%E3%80%8D%E6%9E%97%E5%85%8B%E5%8D%A1%E7%89%B9%E6%A0%91" target="_blank" rel="noopener">题解</a></td><td style="text-align:center">制胡窜 <a href="https://www.luogu.org/problemnew/show/P4384" target="_blank" rel="noopener">链接</a> 暂无题解</td></tr></tbody></table></div><h1 id="「Day-1-Task-1」一双木棋"><a href="#「Day-1-Task-1」一双木棋" class="headerlink" title="「Day 1 / Task 1」一双木棋"></a>「Day 1 / Task 1」一双木棋</h1><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>简单的博弈 + 状态压缩动态规划，使用 map + 记忆化搜索实现即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//「SHOI 2018」Chess</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span>, inf = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[maxn + <span class="number">3</span>][maxn + <span class="number">3</span>], b[maxn + <span class="number">3</span>][maxn + <span class="number">3</span>], r[maxn];</span><br><span class="line">ll p[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;ll, <span class="keyword">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(ll x, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp.count(x)) <span class="keyword">return</span> dp[x];</span><br><span class="line">    <span class="keyword">int</span> &amp;res = dp[x] = type ? inf : -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (r[i] &lt; r[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        r[i]++;</span><br><span class="line">        ll s = x + p[n - i];</span><br><span class="line">        <span class="keyword">if</span> (type) res = min(res, dfs(s, type ^ <span class="number">1</span>) - b[i][r[i]]);</span><br><span class="line">        <span class="keyword">else</span> res = max(res, dfs(s, type ^ <span class="number">1</span>) + a[i][r[i]]);</span><br><span class="line">        r[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i][j]);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = p[i - <span class="number">1</span>] &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    ll t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) t = t &lt;&lt; <span class="number">4</span> | m;</span><br><span class="line">    dp[t] = <span class="number">0</span>, r[<span class="number">0</span>] = m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="「Day-1-Task-2」IIIDX"><a href="#「Day-1-Task-2」IIIDX" class="headerlink" title="「Day 1 / Task 2」IIIDX"></a>「Day 1 / Task 2」IIIDX</h1><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先将 $i$ 和 $\lfloor \frac{i}{k} \rfloor$ 连边，问题转化成给定一棵树，它的 BFS 序是 $1$ 到 $n$，再给定一个序列 $A_1, A_2, \cdots, A_n$，将数填入树中，使得对于每条边父亲的权值小于等于儿子的权值。问字典序最大的方案。</p><p>容易想到试填法，对 $1$ 到 $n$ 号点依次找到它的的最大权值。现在的问题变成了如何快速查询某个点的最大权值。假设点 $v$ 上的数为 $x$，那么它子树中的数要大于等于 $x$，也就是大于等于 $x$ 的数要留下 $\text{size}(v)$ 个。我们将 $A$ 从小到大排序，记 $B_i$ 表示序列中的后 $n - i + 1$ 个数被借走了一些后还剩几个，那么任意时刻都要保证 $B_i \ge 0$。预留 $x$ 个下标大于等于 $i$ 的数就相当于给 $B_1, B_2, \cdots, B_i$ 减去 $x$。查询某个点的最大权值就相当于查询最大的权值 $x$，使得它所在的下标 $i$ 满足 $B_1, B_2, \cdots, B_i \ge \text{size}(v)$（容易发现选的 $i$ 越小越好）。用线段树维护两种操作即可，时间复杂度 $O(n \log n)$。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现的时候注意第二种操作中在权值最大的情况下选的下标必须最小，我们可以开一个 $\text{cnt}$ 数组来 $O(1)$ 完成这个操作。具体见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//「SHOI 2018」IIIDX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (ls | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) / 2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span>, maxm = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n, sz[maxn + <span class="number">3</span>], fa[maxn + <span class="number">3</span>], a[maxn + <span class="number">3</span>], ans[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn + <span class="number">3</span>], mn[maxm + <span class="number">3</span>], tag[maxm + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">double</span> k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        v = G[u][i], fa[v] = u;</span><br><span class="line">        dfs(v), sz[u] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mn[x] = min(mn[ls], mn[rs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> mn[x] = n - l + <span class="number">1</span>, <span class="keyword">void</span>();</span><br><span class="line">    build(ls, l, mid), build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    maintain(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mn[ls] += tag[x], tag[ls] += tag[x];</span><br><span class="line">    mn[rs] += tag[x], tag[rs] += tag[x];</span><br><span class="line">    tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= lx &amp;&amp; r &lt;= rx) <span class="keyword">return</span> mn[x] += y, tag[x] += y, <span class="keyword">void</span>();</span><br><span class="line">    push_down(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) modify(ls, l, mid, lx, rx, y);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) modify(rs, mid + <span class="number">1</span>, r, lx, rx, y);</span><br><span class="line">    maintain(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> y &gt; mn[x] ? l - <span class="number">1</span> : l;</span><br><span class="line">    push_down(x);</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mn[ls]) <span class="keyword">return</span> query(ls, l, mid, y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        G[<span class="keyword">int</span>(i / k)].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cnt[i] = a[i] == a[i - <span class="number">1</span>] ? cnt[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[i] &amp;&amp; !vis[fa[i]]) vis[fa[i]] = <span class="literal">true</span>, modify(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, ans[fa[i]], sz[fa[i]] - <span class="number">1</span>);</span><br><span class="line">        ans[i] = query(<span class="number">1</span>, <span class="number">1</span>, n, sz[i]);</span><br><span class="line">        ans[i] -= cnt[ans[i]], ans[i] += cnt[ans[i]]++;</span><br><span class="line">        modify(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, ans[i], -sz[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, a[ans[i]], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="「Day-2-Task-1」劈配"><a href="#「Day-2-Task-1」劈配" class="headerlink" title="「Day 2 / Task 1」劈配"></a>「Day 2 / Task 1」劈配</h1><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>先考虑求解第一问。将每位选手依次考虑，每次选出可行的最高志愿的导师。考虑二分图匹配，如果匹配的导师还未满员，那么选他一定可行。否则考虑该导师是否有一个学生能够在他已经确定的最高志愿栏目中选出一个其他老师，使得这个方案可行。这个算法十分类似二分图匹配算法。</p><p>接下来考虑第二问。发现答案有单调性，可以二分。每次 $\text{check(id, rank)}$ 时我们一定会取出前 $\text{rank} - 1$ 个人匹配好的结果，然后把 $\text{id}$ 插入进去。我们可以记录前 $i$ 个人劈配好的结果 $(0 \le i &lt; n)$，就可以快速地进行一次二分。</p><p>第一问的时间复杂度 $O(T n^2 C)$，第二问的时间复杂度 $O(T n^2 C \log n)$，可以快速通过本题。</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//「SHOI 2018」Matching</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> T, n, m, b[maxn + <span class="number">3</span>], a[maxn + <span class="number">3</span>][maxn + <span class="number">3</span>], s[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> res[maxn + <span class="number">3</span>], ans[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn + <span class="number">3</span>][maxn + <span class="number">3</span>], lnk[maxn + <span class="number">3</span>], hist[maxn + <span class="number">3</span>][maxn + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> lv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; G[id][lv].size(); i++) &#123;</span><br><span class="line">        x = G[id][lv][i];</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (lnk[x].size() &lt; b[x]) &#123;</span><br><span class="line">            lnk[x].push_back(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, y; j &lt; lnk[x].size(); j++) &#123;</span><br><span class="line">            y = lnk[x][j];</span><br><span class="line">            <span class="keyword">if</span> (match(y, a[y][x])) &#123;</span><br><span class="line">                lnk[x][j] = id;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> low)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        lnk[i] = hist[low][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s[id]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (match(id, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %*d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">            lnk[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                G[i][j].clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) G[i][a[i][j]].push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                hist[i][j] = lnk[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            res[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (match(i, j)) <span class="keyword">break</span>;</span><br><span class="line">                res[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i] &lt;= s[i]) &#123;</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>, mid;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (check(i, mid)) &#123;</span><br><span class="line">                    l = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = i - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, res[i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="「Day-2-Task-2」林克卡特树"><a href="#「Day-2-Task-2」林克卡特树" class="headerlink" title="「Day 2 / Task 2」林克卡特树"></a>「Day 2 / Task 2」林克卡特树</h1><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先将题目转化为最大化 $k + 1$ 条不相交的链的最大权值和。先考虑 $k \le 100$ 的子任务。令    $\text{dp}(u, i, d \in \{0, 1, 2\})$ 表示 $u$ 点的子树中选了 $i$ 条链，$u$ 的度数为 $d$ 的最优解。转移如下：</p><script type="math/tex; mode=display">\begin{cases} \text{dp}(u, i, 0) =  \max\{\max_{v\in \text{son}(u), j} \text{dp}(u, j, 0) + \text{dp}(v, i - j, 0), \text{dp}(u, i - 1, 1), \text{dp}(u, i, 2)\}  \\ \text{dp}(u, i, 1) =  \max_{v\in \text{son}(u), j, t} \text{dp}(u, j, 1 - t) + \text{dp}(v, i - j, t) + t \times w(u, v) \\ \text{dp}(u, i, 2) =  \max_{v\in \text{son}(u), j, t \le 1} \text{dp}(u, j, 2 - t) + \text{dp}(v, i - j - [t = 1], t) + t \times w(u, v)\end{cases}</script><p>时间复杂度 $O(nk)$。</p><p>接下来考虑原题，发现如果在平面直角坐标系中画出 $\left( 1, \text{dp}(1, 1, 0) \right), \left( 2, \text{dp}(1, 2, 0) \right), \cdots$，这些点就会形成一个上凸的函数。于是考虑 $\text{wqs}$ 二分，每次给每条边加上一个值 $v$。令 $\text{dp}(u, d \in \{0, 1, 2\})$ 表示在边权修改后的树上，$u$ 的度数为 $d$ 的最优解。一次 $\text{dp}$ 时间复杂度 $O(n)$，套上二分后总时间复杂度 $O(n \log v)$。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><p>细节较多，具体见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//「SHOI 2018」LCT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">    ll x; <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; x = <span class="number">0</span>, y = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> state &amp;a, <span class="keyword">const</span> state &amp;b) &#123; <span class="keyword">return</span> a.x == b.x ? a.y &gt; b.y : a.x &lt; b.x; &#125;</span><br><span class="line">    <span class="keyword">friend</span> state <span class="keyword">operator</span>+ (<span class="keyword">const</span> state &amp;a, <span class="keyword">const</span> state &amp;b) &#123; <span class="keyword">return</span> &#123; a.x + b.x, a.y + b.y &#125;; &#125;</span><br><span class="line">    <span class="keyword">friend</span> state <span class="keyword">operator</span>+ (<span class="keyword">const</span> state &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123; <span class="keyword">return</span> &#123; a.x + b, a.y &#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>, maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> ll lim = <span class="number">1l</span>l * maxn * <span class="number">1e6</span> + <span class="number">1</span>, inf = <span class="number">1l</span>l * maxn * maxn * <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, tot, ter[maxm + <span class="number">3</span>], wei[maxm + <span class="number">3</span>], nxt[maxm + <span class="number">3</span>], lnk[maxn + <span class="number">3</span>];</span><br><span class="line">state dp[maxn + <span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    ter[++tot] = v, wei[tot] = w;</span><br><span class="line">    nxt[tot] = lnk[u], lnk[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">state <span class="title">new_chain</span><span class="params">(state a, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x - val, a.y + <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, ll val, <span class="keyword">int</span> pa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) dp[u][i].clear();</span><br><span class="line">    dp[u][<span class="number">2</span>] = max(dp[u][<span class="number">2</span>], &#123; -inf, <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[u], v, w; i; i = nxt[i]) &#123;</span><br><span class="line">        v = ter[i], w = wei[i];</span><br><span class="line">        <span class="keyword">if</span> (v == pa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, val, u);</span><br><span class="line">        dp[u][<span class="number">2</span>] = max(dp[u][<span class="number">2</span>] + dp[v][<span class="number">0</span>], new_chain(dp[u][<span class="number">1</span>] + dp[v][<span class="number">1</span>] + w, val));</span><br><span class="line">        dp[u][<span class="number">1</span>] = max(dp[u][<span class="number">1</span>] + dp[v][<span class="number">0</span>], dp[u][<span class="number">0</span>] + dp[v][<span class="number">1</span>] + w);</span><br><span class="line">        dp[u][<span class="number">0</span>] = dp[u][<span class="number">0</span>] + dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[u][<span class="number">0</span>] = max(dp[u][<span class="number">0</span>], max(new_chain(dp[u][<span class="number">1</span>], val), dp[u][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k), k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add_edge(u, v, w), add_edge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    ll l = -lim, r = lim;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ll mid = (l + r + lim * <span class="number">2</span>) / <span class="number">2</span> - lim;</span><br><span class="line">        dfs(<span class="number">1</span>, mid);</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][<span class="number">0</span>].y &lt;= k) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, l);</span><br><span class="line">    state ans = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans.x + k * l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 省选真题 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 二分图匹配 </tag>
            
            <tag> wqs 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「清华集训 2017」某位歌姬的故事（动态规划）</title>
      <link href="/2019/04/01/20190310-UOJ346/"/>
      <url>/2019/04/01/20190310-UOJ346/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p><a href="http://uoj.ac/problem/346" target="_blank" rel="noopener">「清华集训 2017」某位歌姬的故事（UOJ 346）</a></p><p>求满足下列条件的，长度为 $n$ 的正整数序列 $a$ 数量 $\bmod 998244353$ 的结果：</p><ul><li>$\forall a_i \le A$</li><li>$\forall i \in [1, Q], \max \{ a_{l_i}, a_{l_i + 1}, \cdots, a_{r_i} \} = m_i$</li></ul><p>数据范围：$n, A \le 9 \times 10 ^ 8, Q \le 500$。</p><a id="more"></a><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>先将序列离散化。对于离散化后的每一段，处理出这段可能达到的最大值。</p><p>考虑将限制按照最大值分组，最大值相同的限制一起处理，最后将每组的答案相乘得到总答案。其正确性是因为对于每段区间，它只会对包含它的限制的最小值（等于这段可能达到的最大值）贡献，所以贡献是不重不漏的。</p><p>于是问题就转化成了求满足下列条件的，长度为 $n’$ 的正整数序列 $a’$ 数量 $\bmod 998244353$ 的结果：</p><ul><li>$\forall a’_i \le A’$</li><li>$\forall i \in [1, Q’], \max \{ a’_{l’_i}, a’_{l’_i + 1}, \cdots, a’_{r’_i} \} = m’$</li></ul><p>可以使用 $\text{DP}$ 的方法来求解该问题。令 $\text{len}_i$ 表示第 $i$ 段的长度，预处理 $\text{mn}_i$ 表示右端点为第 $i$ 段区间的限制中左端点所在段的最小值。令 $\text{dp}_{i, j}$ 表示考虑到第 $i$ 位，最后一个 $A ^ {\prime}$ 在第 $j$ 段上的方案数。有两种转移：</p><ul><li>$\text{dp}_{i, j} \leftarrow \text{dp}_{i - 1, j} \times (A ^ {\prime} - 1) ^ {\text{len}_i} \ (j \in [\text{mn}_i, i - 1])$</li><li>$\text{dp}_{i, i} \leftarrow \text{dp}_{i - 1, j} \times ((A ^ {\prime}) ^ {\text{len}_i} - (A ^ {\prime} - 1) ^ {\text{len}_i}) \ (j \in [0, i - 1])$</li></ul><p>总时间复杂度 $O(T \times Q^2 \times \log n)$。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500</span>, maxm = <span class="number">2</span> * maxn, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn + <span class="number">3</span>], ok[maxm + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> T, n, q, A, l[maxn + <span class="number">3</span>], r[maxn + <span class="number">3</span>], a[maxn + <span class="number">3</span>], m, pos[maxm + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> M, L[maxm + <span class="number">3</span>], R[maxm + <span class="number">3</span>], mx[maxm + <span class="number">3</span>], mn[maxm + <span class="number">3</span>], Q, tm[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> dp[maxm + <span class="number">3</span>][maxm + <span class="number">3</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V[maxm + <span class="number">3</span>];</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % mod) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) c = <span class="number">1l</span>l * a * c % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line"><span class="comment">// dp[i][j] 表示前 i 位的最后一个当前最大值在 j 的方案数目</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = pos[<span class="number">1</span>]; i &lt;= n; i++, k = pos[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) dp[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x = Pow(w - <span class="number">1</span>, R[k] - L[k] + <span class="number">1</span>), y = Pow(w, R[k] - L[k] + <span class="number">1</span>) - x;</span><br><span class="line">y &lt; <span class="number">0</span> ? y += mod : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= mn[i]) dp[i][j] = (dp[i][j] + <span class="number">1l</span>l * x * dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">dp[i][i] = (dp[i][i] + <span class="number">1l</span>l * y * dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">res += dp[n][i], res &lt; mod ? <span class="number">0</span> : res -= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;q, &amp;A);</span><br><span class="line">m = <span class="number">0</span>, pos[++m] = <span class="number">1</span>, pos[++m] = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;l[i], &amp;r[i], &amp;a[i]);</span><br><span class="line">pos[++m] = l[i], pos[++m] = r[i] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>);</span><br><span class="line">m = unique(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>) - (pos + <span class="number">1</span>);</span><br><span class="line">M = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">L[i] = pos[i], R[i] = pos[i + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">V[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">l[i] = lower_bound(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>, l[i]) - pos;</span><br><span class="line">r[i] = upper_bound(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>, r[i]) - (pos + <span class="number">1</span>);</span><br><span class="line">V[l[i]].push_back(i), V[r[i] + <span class="number">1</span>].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">S.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k: V[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[k]) &#123;</span><br><span class="line">vis[k] = <span class="literal">true</span>;</span><br><span class="line">S.insert(a[k]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">S.erase(S.lower_bound(a[k]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mx[i] = S.empty() ? <span class="number">-1</span> : *S.begin();</span><br><span class="line">&#125;</span><br><span class="line">Q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">tm[++Q] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(tm + <span class="number">1</span>, tm + Q + <span class="number">1</span>);</span><br><span class="line">Q = unique(tm + <span class="number">1</span>, tm + Q + <span class="number">1</span>) - (tm + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) &#123;</span><br><span class="line">m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tm[i] == mx[j]) pos[++m] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) mn[j] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= q; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tm[i] == a[j]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!m) &#123; flag = <span class="literal">false</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">l[j] = lower_bound(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>, l[j]) - pos;</span><br><span class="line">r[j] = upper_bound(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>, r[j]) - (pos + <span class="number">1</span>);</span><br><span class="line">mn[r[j]] = max(mn[r[j]], l[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">ans = <span class="number">1l</span>l * ans * solve(m, tm[i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123; <span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mx[i] == <span class="number">-1</span>) ans = <span class="number">1l</span>l * ans * Pow(A, R[i] - L[i] + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛真题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
