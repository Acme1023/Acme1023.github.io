<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「Codechef SKIRES」Ski Resort（最小割）</title>
      <link href="/2019/04/14/20190414-CC-SKIRES/"/>
      <url>/2019/04/14/20190414-CC-SKIRES/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p><a href="https://vjudge.net/problem/CodeChef-SKIRES" target="_blank" rel="noopener">「Codechef SKIRES」Ski Resort</a></p><p>给定 $n \times m$ 的网格图，每个格子有一个高度 $h_{i, j}$。给一个格子的高度增加 $x$ 需要花费 $x$ 的代价。你要调整某些格子的高度，使得不存在高度单调不下降的，从起点到终点的路径。求需要花费的最小代价。</p><p>数据范围：$n, m \le 50$。</p><a id="more"></a><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>看到 “不存在……的路径” 就想到最小割建图。但是直接对于每对相邻的格子建图不可行，因为一个格子高度的增加可能同时影响到与之相邻的几个格子。也就是说，如果需要使格子 $x$ 的高度比格子 $y_1, y_2, \cdots, y_k$ 大，所需要的代价不是 $\sum_{i = 1}^{k} \text{cost}(x, y_i)$，而是 $\max_{i = 1}^{k} \text{cost}(x, y_i)$，其中 $\text{cost}(x, y)$ 表示格子 $x$ 要比格子 $y$ 高需要花费的代价，也就是 $\max\{0, h(y) - h(x) + 1\}$。</p><p>所以，我们对于每个格子拆点，一起考虑它周围一圈的格子。例如对于下图中的格子：</p><p><img src="https://i.loli.net/2019/04/11/5caf63fc3e2dd.png" alt="图 1"></p><p>需要建如下结构的图：</p><p><img src="https://i.loli.net/2019/04/11/5caf63fc6c631.png" alt="图 2"></p><p>另外注意一些小细节：</p><ul><li>$-1$ 最好提前判掉，否则可能会引起不必要的麻烦。</li><li>起点和终点的建图需要特判，因为题意要求起点和终点的高度不能变化。</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>本菜鸡的 Dinic 跑不过（明明各种优化都加满了啊 QAQ），所以使用了 ISAP 来实现最大流。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">12500</span>, maxm = <span class="number">4e4</span>, inf = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;, dy[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> T, n, m, Rr, Cr, Rt, Ct, s, t, mx, a[maxn + <span class="number">3</span>], b[<span class="number">5</span>], c;</span><br><span class="line"><span class="keyword">int</span> tot, ter[maxm + <span class="number">3</span>], wei[maxm + <span class="number">3</span>], nxt[maxm + <span class="number">3</span>], lnk[maxn + <span class="number">3</span>], dep[maxn + <span class="number">3</span>], gap[maxn + <span class="number">3</span>], cur[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x - <span class="number">1</span>) * m + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">adj</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; <span class="number">1</span> ? x + <span class="number">1</span> : x - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> Rr, <span class="keyword">int</span> Cr, <span class="keyword">int</span> Rt, <span class="keyword">int</span> Ct)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Rr == Rt &amp;&amp; Cr == Ct) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(Rr - Rt) + <span class="built_in">abs</span>(Cr - Ct) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> a[id(Rr, Cr)] &gt;= a[id(Rt, Ct)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a[x] &gt; a[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">ter[++tot] = v, wei[tot] = w;</span><br><span class="line">nxt[tot] = lnk[u], lnk[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_fedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">add_edge(u, v, w), add_edge(v, u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ibfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(gap, <span class="number">0</span>, <span class="keyword">sizeof</span>(gap));</span><br><span class="line"><span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="keyword">sizeof</span>(dep));</span><br><span class="line">dep[s] = <span class="number">1</span>, Q.push(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u; !Q.empty(); ) &#123;</span><br><span class="line">u = Q.front(), Q.pop();</span><br><span class="line">gap[dep[u]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[u], v, w; i; i = nxt[i]) &#123;</span><br><span class="line">v = ter[i], w = wei[adj(i)];</span><br><span class="line"><span class="keyword">if</span> (dep[v]) <span class="keyword">continue</span>;</span><br><span class="line">dep[v] = dep[u] + <span class="number">1</span>, Q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cur[u], v, w, x; i &amp;&amp; ans &lt; flow; i = nxt[i]) &#123;</span><br><span class="line">v = ter[i], w = wei[i];</span><br><span class="line"><span class="keyword">if</span> (w &amp;&amp; dep[v] == dep[u] - <span class="number">1</span>) &#123;</span><br><span class="line">cur[u] = i, x = dfs(v, min(flow - ans, w), s, t);</span><br><span class="line">ans += x, wei[i] -= x, wei[adj(i)] += x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans &lt; flow) &#123;</span><br><span class="line"><span class="keyword">if</span> (!--gap[dep[u]]) dep[s] = mx + <span class="number">1</span>;</span><br><span class="line">++gap[++dep[u]], cur[u] = lnk[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">ibfs(t, s);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(cur, lnk, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line"><span class="keyword">while</span> (dep[s] &lt;= mx) &#123;</span><br><span class="line">ans += dfs(s, inf, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>, &amp;Rr, &amp;Cr, &amp;Rt, &amp;Ct);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[id(i, j)]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (check(Rr, Cr, Rt, Ct)) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">s = id(Rr, Cr), t = id(Rt, Ct), mx = id(n, m);</span><br><span class="line">tot = <span class="number">0</span>, <span class="built_in">memset</span>(lnk, <span class="number">0</span>, <span class="keyword">sizeof</span>(lnk));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (id(i, j) == s || id(i, j) == t) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, x, y; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">x = i + dx[k], y = j + dy[k];</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (a[id(x, y)] &gt;= a[id(i, j)]) &#123;</span><br><span class="line">add_fedge(id(x, y), id(i, j), inf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">add_fedge(id(x, y), id(i, j), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>, x, y; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">x = i + dx[k], y = j + dy[k];</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (a[id(x, y)] &gt;= a[id(i, j)]) b[++c] = id(x, y);</span><br><span class="line">&#125;</span><br><span class="line">sort(b + <span class="number">1</span>, b + c + <span class="number">1</span>, comp);</span><br><span class="line"><span class="keyword">int</span> tmp = id(i, j);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= c; k++) &#123;</span><br><span class="line">++mx, add_fedge(b[k], mx, inf);</span><br><span class="line">add_fedge(mx, tmp, a[b[k]] - a[id(i, j)] + <span class="number">1</span>), tmp = mx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, flow(s, t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SHOI 2019」游记</title>
      <link href="/2019/04/07/20190407-SHOI2019-Travels/"/>
      <url>/2019/04/07/20190407-SHOI2019-Travels/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>清明节放假。上午打了点没用的板子，觉得一些偏的算法比如 Miller-Rabin 应该不会考，就没复习（Flag）。下午颓颓颓，晚上赶到旅馆，准备考试。</p><p>考前有点紧张，感觉 SH 最近 OI 人才辈出，他们都进步很快，我这个小菜鸡就显得有些落后了。不过还是尽自己最大的努力去考吧，没准运气好就进省队了？</p><p>睡的很早，并且几乎一躺下去就睡着了。</p><a id="more"></a><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>考试日。早上吃了很多东西，所以没带零食进考场。</p><p>开题。先花 $30 \text{min}$ 大概看了一下三题。$\text{T}1$ 咋 $k$ 这么小？难道是超级钢琴？$\text{T}2$ 好像 $30$ 分暴力比较 Easy 啊？$\text{T}3$ 是「消失的题面」？出题人毒瘤！</p><p>按照自己定的策略，先打了三题的暴力。$\text{T}1$ $60$，$\text{T}2$ $30$。$\text{T}3$ 怎么才算是暴力呢？把 <code>1</code> 开头的点都看了一下，<code>1?+</code> 和 <code>1wa_998244353</code> 的第二个点好难啊不会做，于是水了 $25$ 分走人了。</p><p>打完暴力后，考试时间已经过半。看 $\text{T}1$，想了 $2 \text{min}$ 后发现这就是个超级钢琴 + 可持久化 Trie 啊！赶紧码码码，过了 $1\text{h}$ 后写完调完，和暴力拍了几组数据，觉得很稳。$\text{T}2$ 想了 $10$ min，看了一下部分分：SA + 线段树优化建图有 $80$ 分？？？考试只剩一个多小时了，有点不敢写，于是就扔了。</p><p>最后的 $1\text{h}$ 检查 + 玩 $\text{T}3$，用 gedit 打开 $\text{T}3$ <code>8.out</code> 的时候，gedit 因为文件太大崩溃了。我可是用 gedit 写代码的啊！尝试手动 kill 掉 gedit 无果，于是重新启动了机器。之后 $\text{T}3$ 的 <code>.out</code> 文件都是用 Guide 打开的。<code>2_p</code>, <code>2_u</code>, <code>2_g</code> 都是啥啊？盯着 <code>2_p</code> 看了好久，把相邻两个 <code>p</code> 位置的差列了出来，诶为啥都是偶数啊？这个序列有啥规律啊？为啥越到后面越稀疏啊？想了好久，才发现这个序列是代表每个数是不是素数的…… woc 我没复习 Miller-Rabin 啊！于是打了线性筛水了 $4$ 分走人了。</p><p>再看看 <code>2_p</code>，woc <code>p</code> 原来是 prime 啊？好端端的 OI 题咋变成首字母填空了啊？于是想 <code>u</code> 和 <code>g</code> 分别代表什么，考试结束也没想出来。</p><p>估分 $100 + 30 + 29 = 159$，感觉要被其他选手虐爆了。</p><p>我们是在华二考的，老师告诉我们下午要去科艺听讲题？这都是什么安排啊……</p><p>中午吃了吉野家，下午赶过去听讲题。</p><p>和邻座同学讨论了一下。同学：$\text{T}2$ 暴力有 $60$ 啊。我：？？？不是只有 $30$ 吗？感觉自己已经输了。</p><p>出榜了，现在只有高中生榜。zjc 大爷 $\text{T}2$ 写的 $80$ 挂成 $50$ 了。zjc：我第三个大样例没过还有 $50$ 啊？有个同学（hwy 巨佬）跟我说他三个大样例都过了啊？我看看他几分啊（翻榜）。诶他怎么挂成 $0$ 分了啊？</p><p>讲题。$\text{T}1$ 我写的是标算。$\text{T}2$ 80 分就是 SA + 线段树优化建图，并且我似乎能多拿 $10$ 分暴力分？$\text{T}3$ 大大大毒瘤，u 是 $\mu$，g 是原根，标算是部分打表。感觉再这样下去以后都能出强制在线题答了 233。</p><p>讲完题后看初中榜。$100 + 40 + 29 = 169$，一分没挂，舒服。</p><p>好像所有写了 $\text{T}2$ 的人都挂分了？QAQ 为他们默哀。</p><p>晚上回去修整，睡得不晚。</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>凌晨醒了。精神状态不是很好，感觉要翻车了。喝了一碗白粥就去考试了。</p><p>开题。$\text{T}1$ 叫皮配？$\text{T}2$, $\text{T}3$ 都是流浪地球系列？$\text{T}1$, $\text{T}3$ 暴力分超少？不算 $\text{T}2$ 只有 $20 + 8$ 的暴力？</p><p>先打了 $20 + 45 + 8$ 的暴力分。写到一半发现电脑死机了？我还没存啊？于是叫来监考，重启了一下电脑。写完后考试时间过半，开始想 $\text{T}1$。过了 $10 \text{min}$ 左右推出了 $50$ 分的 dp 式子，就开始写。写到一半的时候又死机了？？？这是啥破电脑啊？于是监考老师同意给我加时 $5 \text{min}$（才加 $5 \text{min}$ 有啥用啊 QAQ）。重启了电脑重新写，调完后尝试卡常来得到 $80$ 分，但是发现第 $3$ 个样例跑了 $4s$。$5 \times 4(s) = 20s = 10 \times 2(s)$，这是铁定过不了啊。于是 $50$ 分弃疗了。</p><p>$\text{T}2$ 想了一下，做了链的部分分，准备做 $n^2$ 的树形 dp。看了下时间发现只剩不到 $1\text{h}$ 了？这个树形 dp 可真难写啊，于是又扔了。最后肉眼检查了好久，到最后没发现一个错误，感觉好虚啊。</p><p>最终估分 $50 + 60 + 8 = 118$，被其他选手踩爆了。</p><p>出来后和同学聊天。同学：$\text{T}2$ 开几十个线段树就过了啊。我：？？？[惊恐]。看来自己的知识水平还是不够啊。</p><p>中午还是吃完吉野家去听讲课。和 jtl dalao 一起坐。jtl 给我口胡了 $\text{T}2$ std，发现并不是开几十个线段树，而是用一个堆 + 启发式合并的方法。个人感觉这个解法非常妙。我：您是怎么想到的啊？jtl：这个解法很自然啊！我：？？？jtl：我觉得 SH 应该有两位数的 AC 吧。目瞪口呆，自闭了。</p><p>看高中榜。$\text{T}2$ 只有 $2$ 个人做出来，zbw julao 怒 A $\text{T}1$，zjc $\text{T}1$ $90$，$\text{T}3$ $36$ 爆踩了我。zjc：我 $\text{T}3$ 为啥 $52$ 挂成 $36$ 了啊？</p><p>听讲题。$\text{T}1$ $50$，$\text{T}2$ $60$ 都是 PPT 里的标准解法。zbw 光荣上台讲 $\text{T}1$，jtl 光荣上台讲 $\text{T}2$，zjc 光荣上台讲 $\text{T}3$，我在台下光荣自闭。</p><p>看自己的分数，$50 + 60 + 8 = 118$，一分没挂。</p><p>然后就这样挤进队了？只能说自己运气很好吧。</p><p>小黄鸭和管神仙也近队了，恭喜恭喜。</p><p>zjc 爷 NOIP, Day 1, Day 2 都是 SH $\text{rk} 1$，完虐其他所有选手。</p><p>听说 hwy julao D1$\text{T}2$, D2$\text{T}2$ 都是正解，但是都写挂了一个小地方，所以 $\text{rk} 12$ 没进队。太惨了 QAQ。</p><p>回家的路上分析这次考试。先是觉得没肝 D1$\text{T}2$, D2$\text{T}2$ 血亏，但是仔细想想发现求稳的策略其实是最优的。这次省选整体来说还是挺顺利的。</p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h1><p>滚回学校复习期中考试了 QAQ。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「九省联考 2018」部分题解</title>
      <link href="/2019/04/02/20190402-SHOI2018-Tutorial/"/>
      <url>/2019/04/02/20190402-SHOI2018-Tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>快要省选了。这个小菜鸡准备在考前突击一下——把去年的省选题做完。</p><p>但是他太菜了，看了题解之后也只会四道题目。</p><p>今年他究竟能否进入省队呢？让我们拭目以待。</p><a id="more"></a><p>2019.4.7 upd: 最后还是苟进省队了 QAQ</p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>好的现在我们步入正题 —— 九省联考 2018 题解。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Day \ Task</th><th style="text-align:center">Task 1</th><th style="text-align:center">Task 2</th><th style="text-align:center">Task 3</th></tr></thead><tbody><tr><td style="text-align:center">Day 1</td><td style="text-align:center">一双木棋 <a href="https://www.luogu.org/problemnew/show/P4363" target="_blank" rel="noopener">链接</a> <a href="https://acme1023.github.io/2019/04/02/20190402-SHOI2018-Tutorial/#%E3%80%8CDay-1-Task-1%E3%80%8D%E4%B8%80%E5%8F%8C%E6%9C%A8%E6%A3%8B" target="_blank" rel="noopener">题解</a></td><td style="text-align:center">IIIDX <a href="https://www.luogu.org/problemnew/show/P4364" target="_blank" rel="noopener">链接</a> <a href="https://acme1023.github.io/2019/04/02/20190402-SHOI2018-Tutorial/#%E3%80%8CDay-1-Task-2%E3%80%8DIIIDX" target="_blank" rel="noopener">题解</a></td><td style="text-align:center">秘密袭击 <a href="https://www.luogu.org/problemnew/show/P4365" target="_blank" rel="noopener">链接</a> 暂无题解</td></tr><tr><td style="text-align:center">Day 2</td><td style="text-align:center">劈配 <a href="https://www.luogu.org/problemnew/show/P4382" target="_blank" rel="noopener">链接</a> <a href="https://acme1023.github.io/2019/04/02/20190402-SHOI2018-Tutorial/#%E3%80%8CDay-2-Task-1%E3%80%8D%E5%8A%88%E9%85%8D" target="_blank" rel="noopener">题解</a></td><td style="text-align:center">林克卡特树 <a href="https://www.luogu.org/problemnew/show/P4383" target="_blank" rel="noopener">链接</a> <a href="https://acme1023.github.io/2019/04/02/20190402-SHOI2018-Tutorial/#%E3%80%8CDay-2-Task-2%E3%80%8D%E6%9E%97%E5%85%8B%E5%8D%A1%E7%89%B9%E6%A0%91" target="_blank" rel="noopener">题解</a></td><td style="text-align:center">制胡窜 <a href="https://www.luogu.org/problemnew/show/P4384" target="_blank" rel="noopener">链接</a> 暂无题解</td></tr></tbody></table></div><h1 id="「Day-1-Task-1」一双木棋"><a href="#「Day-1-Task-1」一双木棋" class="headerlink" title="「Day 1 / Task 1」一双木棋"></a>「Day 1 / Task 1」一双木棋</h1><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>简单的博弈 + 状态压缩动态规划，使用 map + 记忆化搜索实现即可。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//「SHOI 2018」Chess</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10</span>, inf = <span class="number">1e9</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[maxn + <span class="number">3</span>][maxn + <span class="number">3</span>], b[maxn + <span class="number">3</span>][maxn + <span class="number">3</span>], r[maxn];</span><br><span class="line">ll p[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;ll, <span class="keyword">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(ll x, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp.count(x)) <span class="keyword">return</span> dp[x];</span><br><span class="line">    <span class="keyword">int</span> &amp;res = dp[x] = type ? inf : -inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (r[i] &lt; r[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        r[i]++;</span><br><span class="line">        ll s = x + p[n - i];</span><br><span class="line">        <span class="keyword">if</span> (type) res = min(res, dfs(s, type ^ <span class="number">1</span>) - b[i][r[i]]);</span><br><span class="line">        <span class="keyword">else</span> res = max(res, dfs(s, type ^ <span class="number">1</span>) + a[i][r[i]]);</span><br><span class="line">        r[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i][j]);</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = p[i - <span class="number">1</span>] &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    ll t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) t = t &lt;&lt; <span class="number">4</span> | m;</span><br><span class="line">    dp[t] = <span class="number">0</span>, r[<span class="number">0</span>] = m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dfs(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="「Day-1-Task-2」IIIDX"><a href="#「Day-1-Task-2」IIIDX" class="headerlink" title="「Day 1 / Task 2」IIIDX"></a>「Day 1 / Task 2」IIIDX</h1><h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先将 $i$ 和 $\lfloor \frac{i}{k} \rfloor$ 连边，问题转化成给定一棵树，它的 BFS 序是 $1$ 到 $n$，再给定一个序列 $A_1, A_2, \cdots, A_n$，将数填入树中，使得对于每条边父亲的权值小于等于儿子的权值。问字典序最大的方案。</p><p>容易想到试填法，对 $1$ 到 $n$ 号点依次找到它的的最大权值。现在的问题变成了如何快速查询某个点的最大权值。假设点 $v$ 上的数为 $x$，那么它子树中的数要大于等于 $x$，也就是大于等于 $x$ 的数要留下 $\text{size}(v)$ 个。我们将 $A$ 从小到大排序，记 $B_i$ 表示序列中的后 $n - i + 1$ 个数被借走了一些后还剩几个，那么任意时刻都要保证 $B_i \ge 0$。预留 $x$ 个下标大于等于 $i$ 的数就相当于给 $B_1, B_2, \cdots, B_i$ 减去 $x$。查询某个点的最大权值就相当于查询最大的权值 $x$，使得它所在的下标 $i$ 满足 $B_1, B_2, \cdots, B_i \ge \text{size}(v)$（容易发现选的 $i$ 越小越好）。用线段树维护两种操作即可，时间复杂度 $O(n \log n)$。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>实现的时候注意第二种操作中在权值最大的情况下选的下标必须最小，我们可以开一个 $\text{cnt}$ 数组来 $O(1)$ 完成这个操作。具体见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//「SHOI 2018」IIIDX</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (ls | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) / 2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span>, maxm = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n, sz[maxn + <span class="number">3</span>], fa[maxn + <span class="number">3</span>], a[maxn + <span class="number">3</span>], ans[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[maxn + <span class="number">3</span>], mn[maxm + <span class="number">3</span>], tag[maxm + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">double</span> k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; G[u].size(); i++) &#123;</span><br><span class="line">        v = G[u][i], fa[v] = u;</span><br><span class="line">        dfs(v), sz[u] += sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mn[x] = min(mn[ls], mn[rs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> mn[x] = n - l + <span class="number">1</span>, <span class="keyword">void</span>();</span><br><span class="line">    build(ls, l, mid), build(rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    maintain(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    mn[ls] += tag[x], tag[ls] += tag[x];</span><br><span class="line">    mn[rs] += tag[x], tag[rs] += tag[x];</span><br><span class="line">    tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= lx &amp;&amp; r &lt;= rx) <span class="keyword">return</span> mn[x] += y, tag[x] += y, <span class="keyword">void</span>();</span><br><span class="line">    push_down(x);</span><br><span class="line">    <span class="keyword">if</span> (lx &lt;= mid) modify(ls, l, mid, lx, rx, y);</span><br><span class="line">    <span class="keyword">if</span> (rx &gt; mid) modify(rs, mid + <span class="number">1</span>, r, lx, rx, y);</span><br><span class="line">    maintain(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> y &gt; mn[x] ? l - <span class="number">1</span> : l;</span><br><span class="line">    push_down(x);</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mn[ls]) <span class="keyword">return</span> query(ls, l, mid, y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(rs, mid + <span class="number">1</span>, r, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        G[<span class="keyword">int</span>(i / k)].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cnt[i] = a[i] == a[i - <span class="number">1</span>] ? cnt[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[i] &amp;&amp; !vis[fa[i]]) vis[fa[i]] = <span class="literal">true</span>, modify(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, ans[fa[i]], sz[fa[i]] - <span class="number">1</span>);</span><br><span class="line">        ans[i] = query(<span class="number">1</span>, <span class="number">1</span>, n, sz[i]);</span><br><span class="line">        ans[i] -= cnt[ans[i]], ans[i] += cnt[ans[i]]++;</span><br><span class="line">        modify(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, ans[i], -sz[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, a[ans[i]], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="「Day-2-Task-1」劈配"><a href="#「Day-2-Task-1」劈配" class="headerlink" title="「Day 2 / Task 1」劈配"></a>「Day 2 / Task 1」劈配</h1><h2 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h2><p>先考虑求解第一问。将每位选手依次考虑，每次选出可行的最高志愿的导师。考虑二分图匹配，如果匹配的导师还未满员，那么选他一定可行。否则考虑该导师是否有一个学生能够在他已经确定的最高志愿栏目中选出一个其他老师，使得这个方案可行。这个算法十分类似二分图匹配算法。</p><p>接下来考虑第二问。发现答案有单调性，可以二分。每次 $\text{check(id, rank)}$ 时我们一定会取出前 $\text{rank} - 1$ 个人匹配好的结果，然后把 $\text{id}$ 插入进去。我们可以记录前 $i$ 个人劈配好的结果 $(0 \le i &lt; n)$，就可以快速地进行一次二分。</p><p>第一问的时间复杂度 $O(T n^2 C)$，第二问的时间复杂度 $O(T n^2 C \log n)$，可以快速通过本题。</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//「SHOI 2018」Matching</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> T, n, m, b[maxn + <span class="number">3</span>], a[maxn + <span class="number">3</span>][maxn + <span class="number">3</span>], s[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> res[maxn + <span class="number">3</span>], ans[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn + <span class="number">3</span>][maxn + <span class="number">3</span>], lnk[maxn + <span class="number">3</span>], hist[maxn + <span class="number">3</span>][maxn + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> lv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; G[id][lv].size(); i++) &#123;</span><br><span class="line">        x = G[id][lv][i];</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (lnk[x].size() &lt; b[x]) &#123;</span><br><span class="line">            lnk[x].push_back(id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, y; j &lt; lnk[x].size(); j++) &#123;</span><br><span class="line">            y = lnk[x][j];</span><br><span class="line">            <span class="keyword">if</span> (match(y, a[y][x])) &#123;</span><br><span class="line">                lnk[x][j] = id;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> low)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        lnk[i] = hist[low][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s[id]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (match(id, i)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %*d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">            lnk[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                G[i][j].clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) G[i][a[i][j]].push_back(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                hist[i][j] = lnk[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            res[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (match(i, j)) <span class="keyword">break</span>;</span><br><span class="line">                res[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i] &lt;= s[i]) &#123;</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = i - <span class="number">1</span>, mid;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (check(i, mid)) &#123;</span><br><span class="line">                    l = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = i - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, res[i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="「Day-2-Task-2」林克卡特树"><a href="#「Day-2-Task-2」林克卡特树" class="headerlink" title="「Day 2 / Task 2」林克卡特树"></a>「Day 2 / Task 2」林克卡特树</h1><h2 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h2><p>首先将题目转化为最大化 $k + 1$ 条不相交的链的最大权值和。先考虑 $k \le 100$ 的子任务。令    $\text{dp}(u, i, d \in \{0, 1, 2\})$ 表示 $u$ 点的子树中选了 $i$ 条链，$u$ 的度数为 $d$ 的最优解。转移如下：</p><script type="math/tex; mode=display">\begin{cases} \text{dp}(u, i, 0) =  \max\{\max_{v\in \text{son}(u), j} \text{dp}(u, j, 0) + \text{dp}(v, i - j, 0), \text{dp}(u, i - 1, 1), \text{dp}(u, i, 2)\}  \\ \text{dp}(u, i, 1) =  \max_{v\in \text{son}(u), j, t} \text{dp}(u, j, 1 - t) + \text{dp}(v, i - j, t) + t \times w(u, v) \\ \text{dp}(u, i, 2) =  \max_{v\in \text{son}(u), j, t \le 1} \text{dp}(u, j, 2 - t) + \text{dp}(v, i - j - [t = 1], t) + t \times w(u, v)\end{cases}</script><p>时间复杂度 $O(nk)$。</p><p>接下来考虑原题，发现如果在平面直角坐标系中画出 $\left( 1, \text{dp}(1, 1, 0) \right), \left( 2, \text{dp}(1, 2, 0) \right), \cdots$，这些点就会形成一个上凸的函数。于是考虑 $\text{wqs}$ 二分，每次给每条边加上一个值 $v$。令 $\text{dp}(u, d \in \{0, 1, 2\})$ 表示在边权修改后的树上，$u$ 的度数为 $d$ 的最优解。一次 $\text{dp}$ 时间复杂度 $O(n)$，套上二分后总时间复杂度 $O(n \log v)$。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><p>细节较多，具体见代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//「SHOI 2018」LCT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">    ll x; <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; x = <span class="number">0</span>, y = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> state &amp;a, <span class="keyword">const</span> state &amp;b) &#123; <span class="keyword">return</span> a.x == b.x ? a.y &gt; b.y : a.x &lt; b.x; &#125;</span><br><span class="line">    <span class="keyword">friend</span> state <span class="keyword">operator</span>+ (<span class="keyword">const</span> state &amp;a, <span class="keyword">const</span> state &amp;b) &#123; <span class="keyword">return</span> &#123; a.x + b.x, a.y + b.y &#125;; &#125;</span><br><span class="line">    <span class="keyword">friend</span> state <span class="keyword">operator</span>+ (<span class="keyword">const</span> state &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b) &#123; <span class="keyword">return</span> &#123; a.x + b, a.y &#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">3e5</span>, maxm = <span class="number">2</span> * maxn;</span><br><span class="line"><span class="keyword">const</span> ll lim = <span class="number">1l</span>l * maxn * <span class="number">1e6</span> + <span class="number">1</span>, inf = <span class="number">1l</span>l * maxn * maxn * <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, tot, ter[maxm + <span class="number">3</span>], wei[maxm + <span class="number">3</span>], nxt[maxm + <span class="number">3</span>], lnk[maxn + <span class="number">3</span>];</span><br><span class="line">state dp[maxn + <span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    ter[++tot] = v, wei[tot] = w;</span><br><span class="line">    nxt[tot] = lnk[u], lnk[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">state <span class="title">new_chain</span><span class="params">(state a, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a.x - val, a.y + <span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, ll val, <span class="keyword">int</span> pa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) dp[u][i].clear();</span><br><span class="line">    dp[u][<span class="number">2</span>] = max(dp[u][<span class="number">2</span>], &#123; -inf, <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lnk[u], v, w; i; i = nxt[i]) &#123;</span><br><span class="line">        v = ter[i], w = wei[i];</span><br><span class="line">        <span class="keyword">if</span> (v == pa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, val, u);</span><br><span class="line">        dp[u][<span class="number">2</span>] = max(dp[u][<span class="number">2</span>] + dp[v][<span class="number">0</span>], new_chain(dp[u][<span class="number">1</span>] + dp[v][<span class="number">1</span>] + w, val));</span><br><span class="line">        dp[u][<span class="number">1</span>] = max(dp[u][<span class="number">1</span>] + dp[v][<span class="number">0</span>], dp[u][<span class="number">0</span>] + dp[v][<span class="number">1</span>] + w);</span><br><span class="line">        dp[u][<span class="number">0</span>] = dp[u][<span class="number">0</span>] + dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[u][<span class="number">0</span>] = max(dp[u][<span class="number">0</span>], max(new_chain(dp[u][<span class="number">1</span>], val), dp[u][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k), k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        add_edge(u, v, w), add_edge(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line">    ll l = -lim, r = lim;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        ll mid = (l + r + lim * <span class="number">2</span>) / <span class="number">2</span> - lim;</span><br><span class="line">        dfs(<span class="number">1</span>, mid);</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][<span class="number">0</span>].y &lt;= k) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, l);</span><br><span class="line">    state ans = dp[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans.x + k * l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 省选真题 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 二分图匹配 </tag>
            
            <tag> wqs 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「清华集训 2017」某位歌姬的故事（动态规划）</title>
      <link href="/2019/04/01/20190401-UOJ346/"/>
      <url>/2019/04/01/20190401-UOJ346/</url>
      
        <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p><a href="http://uoj.ac/problem/346" target="_blank" rel="noopener">「清华集训 2017」某位歌姬的故事（UOJ 346）</a></p><p>求满足下列条件的，长度为 $n$ 的正整数序列 $a$ 数量 $\bmod 998244353$ 的结果：</p><ul><li>$\forall a_i \le A$</li><li>$\forall i \in [1, Q], \max \{ a_{l_i}, a_{l_i + 1}, \cdots, a_{r_i} \} = m_i$</li></ul><p>数据范围：$n, A \le 9 \times 10 ^ 8, Q \le 500$。</p><a id="more"></a><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>先将序列离散化。对于离散化后的每一段，处理出这段可能达到的最大值。</p><p>考虑将限制按照最大值分组，最大值相同的限制一起处理，最后将每组的答案相乘得到总答案。其正确性是因为对于每段区间，它只会对包含它的限制的最小值（等于这段可能达到的最大值）贡献，所以贡献是不重不漏的。</p><p>于是问题就转化成了求满足下列条件的，长度为 $n’$ 的正整数序列 $a’$ 数量 $\bmod 998244353$ 的结果：</p><ul><li>$\forall a’_i \le A’$</li><li>$\forall i \in [1, Q’], \max \{ a’_{l’_i}, a’_{l’_i + 1}, \cdots, a’_{r’_i} \} = m’$</li></ul><p>可以使用 $\text{DP}$ 的方法来求解该问题。令 $\text{len}_i$ 表示第 $i$ 段的长度，预处理 $\text{mn}_i$ 表示右端点为第 $i$ 段区间的限制中左端点所在段的最小值。令 $\text{dp}_{i, j}$ 表示考虑到第 $i$ 位，最后一个 $A ^ {\prime}$ 在第 $j$ 段上的方案数。有两种转移：</p><ul><li>$\text{dp}_{i, j} \leftarrow \text{dp}_{i - 1, j} \times (A ^ {\prime} - 1) ^ {\text{len}_i} \ (j \in [\text{mn}_i, i - 1])$</li><li>$\text{dp}_{i, i} \leftarrow \text{dp}_{i - 1, j} \times ((A ^ {\prime}) ^ {\text{len}_i} - (A ^ {\prime} - 1) ^ {\text{len}_i}) \ (j \in [0, i - 1])$</li></ul><p>总时间复杂度 $O(T \times Q^2 \times \log n)$。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">500</span>, maxm = <span class="number">2</span> * maxn, mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn + <span class="number">3</span>], ok[maxm + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> T, n, q, A, l[maxn + <span class="number">3</span>], r[maxn + <span class="number">3</span>], a[maxn + <span class="number">3</span>], m, pos[maxm + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> M, L[maxm + <span class="number">3</span>], R[maxm + <span class="number">3</span>], mx[maxm + <span class="number">3</span>], mn[maxm + <span class="number">3</span>], Q, tm[maxn + <span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> dp[maxm + <span class="number">3</span>][maxm + <span class="number">3</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V[maxm + <span class="number">3</span>];</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="number">1l</span>l * a * a % mod) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) c = <span class="number">1l</span>l * a * c % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line"><span class="comment">// dp[i][j] 表示前 i 位的最后一个当前最大值在 j 的方案数目</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = pos[<span class="number">1</span>]; i &lt;= n; i++, k = pos[i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) dp[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x = Pow(w - <span class="number">1</span>, R[k] - L[k] + <span class="number">1</span>), y = Pow(w, R[k] - L[k] + <span class="number">1</span>) - x;</span><br><span class="line">y &lt; <span class="number">0</span> ? y += mod : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= mn[i]) dp[i][j] = (dp[i][j] + <span class="number">1l</span>l * x * dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">dp[i][i] = (dp[i][i] + <span class="number">1l</span>l * y * dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">res += dp[n][i], res &lt; mod ? <span class="number">0</span> : res -= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;q, &amp;A);</span><br><span class="line">m = <span class="number">0</span>, pos[++m] = <span class="number">1</span>, pos[++m] = n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;l[i], &amp;r[i], &amp;a[i]);</span><br><span class="line">pos[++m] = l[i], pos[++m] = r[i] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>);</span><br><span class="line">m = unique(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>) - (pos + <span class="number">1</span>);</span><br><span class="line">M = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">L[i] = pos[i], R[i] = pos[i + <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">V[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">l[i] = lower_bound(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>, l[i]) - pos;</span><br><span class="line">r[i] = upper_bound(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>, r[i]) - (pos + <span class="number">1</span>);</span><br><span class="line">V[l[i]].push_back(i), V[r[i] + <span class="number">1</span>].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">S.clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k: V[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[k]) &#123;</span><br><span class="line">vis[k] = <span class="literal">true</span>;</span><br><span class="line">S.insert(a[k]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">S.erase(S.lower_bound(a[k]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mx[i] = S.empty() ? <span class="number">-1</span> : *S.begin();</span><br><span class="line">&#125;</span><br><span class="line">Q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">tm[++Q] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(tm + <span class="number">1</span>, tm + Q + <span class="number">1</span>);</span><br><span class="line">Q = unique(tm + <span class="number">1</span>, tm + Q + <span class="number">1</span>) - (tm + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) &#123;</span><br><span class="line">m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tm[i] == mx[j]) pos[++m] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) mn[j] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= q; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (tm[i] == a[j]) &#123;</span><br><span class="line"><span class="keyword">if</span> (!m) &#123; flag = <span class="literal">false</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">l[j] = lower_bound(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>, l[j]) - pos;</span><br><span class="line">r[j] = upper_bound(pos + <span class="number">1</span>, pos + m + <span class="number">1</span>, r[j]) - (pos + <span class="number">1</span>);</span><br><span class="line">mn[r[j]] = max(mn[r[j]], l[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">ans = <span class="number">1l</span>l * ans * solve(m, tm[i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) &#123; <span class="built_in">puts</span>(<span class="string">"0"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (mx[i] == <span class="number">-1</span>) ans = <span class="number">1l</span>l * ans * Pow(A, R[i] - L[i] + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 比赛真题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
